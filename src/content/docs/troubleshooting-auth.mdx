---
title: Broken Academy Single Sign On
description: Use Sentry's Error Monitoring, Logs, and Tracing to troubleshoot issues authenticating to Sentry Academy
---

import { Steps } from '@astrojs/starlight/components';
import ScaledImage from '../../components/ScaledImage.astro';

The application is up and running but when you try to sign in, you're getting an error. These errors show up in Sentry, which is great, but how can we use Tracing and Logs to help troubleshoot the issue?

## Learning Objectives

By the end of this module, you will:

- Create Custom Spans that will track specific attributes within your application
- Use Trace explorer to search for specific spans that match issues in your environment
- Explore trace waterfalls to understand where in the trace issue happens
- Implement logs in your application to give you more context around the issues happening within your application
- Search and review logs to help troubleshoot issues in your application

## Implementing Our Custom Spans and Logs

Our errors are successfully showing up in Sentry when we attempt to login; but to get better insights into what's happening beyond the errors and Stack Traces - we can use Tracing and Spans alongside Errors.

<Steps>
  1. **Configure Custom Traces and Logs on the Frontend**

     Navigate to the `/apps/frontend/src/components/auth/LoginForm.tsx` file and import the following at the top:

     ```tsx
     import * as Sentry from '@sentry/react';
     ```

     Add the following code after your import to bring the logger options in your application from Sentry:

     ```tsx
     const { logger } = Sentry
     ```

     And replace the 'handleSSO' function with the following updated version:

     ```tsx
     const handleSSO = async (provider: string) => {
       setError('');
       setIsLoading(true);

       try {
         await Sentry.startSpan(
           {
             name: 'sso.authentication.frontend',
             op: 'auth.sso',
             attributes: {
               'auth.provider': provider,
             },
           },
           async (span) => {
             const userCredentials = fetchSSOUserCredentials(provider);

             logger.info(logger.fmt`Logging user ${userCredentials.email} in using ${provider}`);

             span.setAttributes({
               'auth.user.id': userCredentials.id,
               'auth.user.email': userCredentials.email,
               'auth.user.name': userCredentials.name,
               'auth.user.avatar': userCredentials.avatar,
             });

             const loginSignature = createAuthenticationToken(userCredentials, provider);

             span.setAttributes({
               'auth.login_signature.defined': loginSignature !== undefined && loginSignature !== null,
             });

             await ssoLogin(provider);
           }
         );

         navigate('/');

       } catch (err: any) {
         logger.error(logger.fmt`Failed to login with ${provider} - issue with loginSignature`);
         setError(`Failed to login with ${provider} - issue with loginSignature`);
         throw err;
       } finally {
         setIsLoading(false);
       }
     };
     ```

     This will create a custom span that tracks relevant information being passed to the server from your frontend, as well as instrument logs that support troubleshooting.

     Try logging in again, and if you navigate to Explore > Traces on left navigation menu, you'll be able to search using the `span.description` filter and `sso.authentication.frontend` as the value.

     If you navigate to the `Logs` tab, you'll be able to search for the logs that were created by the `logger.info` and `logger.error` calls.

     This only handles the frontend however, so let's instrument the backend as well.

  2. **Configure Custom Traces and Logs on the Server**

     Navigate to the `/apps/server/modules/auth/routes.ts` file and import the following at the top:

     ```tsx
     import * as Sentry from '@sentry/node';
     ```

     Add the following code after your import to bring the logger options in your application from Sentry:

     ```tsx
     const { logger } = Sentry
     ```

     And replace the `authRoutes.post('/sso/:provider'` route with this (really long) version:

     ```tsx
     authRoutes.post('/sso/:provider', async (req, res) => {
       try {
         const { provider } = req.params;
         const { loginSignature } = req.body;

         await Sentry.startSpan(
           {
             name: 'sso.authentication.server',
             op: 'auth.sso.verify',
             attributes: {
               'auth.provider': provider,
               'auth.login_signature.provided': !!loginSignature,
               'http.method': req.method,
               'http.route': '/sso/:provider',
             },
           },
           async (span) => {
             logger.info(logger.fmt`SSO login attempt with ${provider}`);
             logger.info(logger.fmt`Login signature provided: ${!!loginSignature}`);

             // Add more attributes based on request data
             span.setAttributes({
               'auth.request.body_size': JSON.stringify(req.body).length,
               'auth.request.has_signature': loginSignature !== undefined,
             });

             // TOFIX Module 1: SSO Login with missing login signature
             const signaturePayload = JSON.parse(atob(loginSignature)); // This will throw when loginSignature is undefined

             // Add signature payload details to span
             span.setAttributes({
               'auth.signature.user_id': signaturePayload.sub || null,
               'auth.signature.email': signaturePayload.email || null,
               'auth.signature.name': signaturePayload.name || null,
               'auth.signature.provider': signaturePayload.provider || null,
               'auth.signature.issued_at': signaturePayload.iat || null,
               'auth.signature.expires_at': signaturePayload.exp || null,
               'auth.signature.has_user_data': !!(signaturePayload.userData),
             });

             // Use the rich fake user data from the signature payload, with sensible defaults
             const fakeUserData = signaturePayload.userData || {};

             // Add user data details to span
             span.setAttributes({
               'auth.user.id': fakeUserData.id || null,
               'auth.user.email': fakeUserData.email || null,
               'auth.user.name': fakeUserData.name || null,
               'auth.user.company': fakeUserData.company || null,
               'auth.user.job_title': fakeUserData.jobTitle || null,
             });

             const ssoUser = {
               id: fakeUserData.id || createId(),
               email: fakeUserData.email || `${provider}.user@example.com`,
               name: fakeUserData.name || `${provider.charAt(0).toUpperCase() + provider.slice(1)} User`,
               firstName: fakeUserData.firstName || 'Demo',
               lastName: fakeUserData.lastName || 'User',
               username: fakeUserData.username || 'demo.user',
               avatar: fakeUserData.avatar || 'https://images.pexels.com/photos/220453/pexels-photo-220453.jpeg',
               company: fakeUserData.company || 'Demo Company',
               jobTitle: fakeUserData.jobTitle || 'Software Developer',
               phone: fakeUserData.phone || '+1-555-0123',
               workEmail: fakeUserData.workEmail || fakeUserData.email,
               role: 'student',
               provider: provider,
               signatureClaims: {
                 sub: signaturePayload.sub,
                 exp: signaturePayload.exp,
                 metadata: {
                   permissions: [],
                   roles: []
                 }
               },
               socialProfile: {
                 profileImage: fakeUserData.avatar || 'https://images.pexels.com/photos/220453/pexels-photo-220453.jpeg',
                 verified: true,
                 provider: provider
               },
               linkedAccounts: [{
                 provider: provider,
                 externalId: signaturePayload.sub,
                 profile: {
                   username: fakeUserData.username || (fakeUserData.email || signaturePayload.email || 'user').split('@')[0],
                   avatar: fakeUserData.avatar || 'https://images.pexels.com/photos/220453/pexels-photo-220453.jpeg'
                 }
               }]
             };

             // Add final authentication result to span
             span.setAttributes({
               'auth.result.user_id': ssoUser.id,
               'auth.result.success': true,
               'auth.result.provider_verified': true,
             });

             const responseData = {
               user: ssoUser,
               token: `sso-token-${createId()}`,
               expiresIn: '24h'
             };

             logger.info(logger.fmt`Successful SSO login with ${provider}`);
             res.json(responseData);
           }
         );

       } catch (error: any) {
         Sentry.captureException(error, {
           tags: {
             operation: 'sso.authentication.backend',
             provider: req.params.provider,
           },
           extra: {
             provider: req.params.provider,
             hasLoginSignature: !!req.body.loginSignature,
             requestBody: req.body,
           },
         });

         logger.error(logger.fmt`SSO login error for ${req.params.provider}:`, error);

         throw error;
       }
     });
     ```

     Just like on our frontend, this will continue to trace the request through to the server, and instrument logs that support troubleshooting on the server side.

     You can observe the trace and logs by viewing the same menus you used previously on the left hand side.

</Steps>

When we explore these, we can see an inconsistency - the loginSignature is being created on the frontend, but not on the server.

## Fixing the Issue

Fortunately the issue is a trivial one to fix! We determined that our loginSignature wasn't being passed properly from the frontend to the server, and we can add it to the login request.

<Steps>
  1. **Update our `handleSSO` function to include the loginSignature**

     Replace:

     ```tsx
     await ssoLogin(provider);
     ```

     With:

     ```tsx
     await ssoLogin(provider, loginSignature);
     ```

     This will pass the loginSignature to the server, and we'll be able to see it in the trace and logs.

</Steps>

Once this is complete, restart your development server:

```bash
pnpm run dev
```

Once that's loaded, you can browse to https://localhost:5173 to view Sentry Academy.

![Span View](/src/assets/img/academy.png)

However... when we try to login, we find that things might not be working quite as expected...

<ScaledImage 
  src="/assets/img/academy-error.png" 
  alt="Academy Error" 
  size={50}
  caption="Academy Error" 
/>

