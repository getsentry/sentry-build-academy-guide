---
title: Tracing for Database queries, Queues, and Caches
description: Instrument database queries, background jobs, and caching layers for complete visibility
---

import { Steps } from '@astrojs/starlight/components';

Your application's data layer and background processes are critical for performance and reliability. In this module, you'll learn how to instrument database queries, message queues, and caching layers to get complete visibility into your application's behavior.

## Learning Objectives

By the end of this module, you will:

- Instrument database queries with detailed performance metrics
- Set up tracing for background job processing
- Monitor cache hit rates and performance
- Track data layer errors and slow queries
- Understand query patterns and optimization opportunities

## Database Query Instrumentation

### SQLite/Database Queries with Bun

Let's instrument database operations in your Bun backend:

:::tip[Database Performance]
Database queries are often the biggest performance bottleneck in web applications. Proper instrumentation helps you identify:
- Slow queries that need optimization
- N+1 query problems
- Missing database indexes
- Connection pool issues
:::

![Database Trace](/src/assets/img/DatabaseTrace.png)

<Steps>
  1. **Create Database Connection with Instrumentation**

     ```js
     import * as Sentry from "@sentry/bun";
     import { Database } from "bun:sqlite";

     class InstrumentedDatabase {
       constructor(path) {
         this.db = new Database(path);
         this.setupInstrumentation();
       }

       setupInstrumentation() {
         // Wrap the original query method
         const originalQuery = this.db.query.bind(this.db);
         
         this.db.query = (sql, params = []) => {
           const statement = originalQuery(sql);
           
           // Return instrumented statement
           return {
             ...statement,
             all: (...args) => this.instrumentQuery('all', sql, params, () => statement.all(...args)),
             get: (...args) => this.instrumentQuery('get', sql, params, () => statement.get(...args)),
             run: (...args) => this.instrumentQuery('run', sql, params, () => statement.run(...args)),
           };
         };
       }

       async instrumentQuery(operation, sql, params, queryFn) {
         return Sentry.startSpan(
           {
             name: `db.${operation}`,
             attributes: {
               "db.system": "sqlite",
               "db.statement": sql,
               "db.operation": this.extractOperation(sql),
               "db.table": this.extractTable(sql)
             }
           },
           async (span) => {
             const startTime = performance.now();
             
             try {
               // Set additional attributes
               span.setAttributes({
                 "db.params_count": params.length,
                 "db.query_type": operation
               });

               const result = queryFn();
               const duration = performance.now() - startTime;

               // Record successful query metrics
               span.setAttributes({
                 "db.duration": duration,
                 "db.rows_affected": Array.isArray(result) ? result.length : 1,
                 "operation.success": true
               });

               // Track database performance metrics
               Sentry.metrics.timing('db.query.duration', duration, {
                 tags: {
                   operation: this.extractOperation(sql),
                   table: this.extractTable(sql),
                   query_type: operation
                 }
               });

               // Track slow queries
               if (duration > 100) {
                 Sentry.addBreadcrumb({
                   message: 'Slow database query detected',
                   category: 'database',
                   level: 'warning',
                   data: {
                     sql,
                     duration,
                     operation
                   }
                 });

                 Sentry.metrics.increment('db.slow_queries', 1, {
                   tags: {
                     table: this.extractTable(sql),
                     operation: this.extractOperation(sql)
                   }
                 });
               }

               return result;

             } catch (error) {
               const duration = performance.now() - startTime;
               
               span.recordException(error);
               span.setAttributes({
                 "db.duration": duration,
                 "operation.success": false,
                 "error.type": error.name
               });

               // Track database errors
               Sentry.metrics.increment('db.errors', 1, {
                 tags: {
                   error_type: error.name,
                   operation: this.extractOperation(sql)
                 }
               });

               throw error;
             }
           }
         );
       }

       extractOperation(sql) {
         const match = sql.trim().match(/^(SELECT|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER)/i);
         return match ? match[1].toUpperCase() : 'UNKNOWN';
       }

       extractTable(sql) {
         // Simple table extraction - you might want to make this more robust
         const fromMatch = sql.match(/FROM\s+(\w+)/i);
         const intoMatch = sql.match(/INTO\s+(\w+)/i);
         const updateMatch = sql.match(/UPDATE\s+(\w+)/i);
         
         return fromMatch?.[1] || intoMatch?.[1] || updateMatch?.[1] || 'unknown';
       }
     }

     // Usage
     export const db = new InstrumentedDatabase("./database.sqlite");
     ```

  2. **Create Repository Pattern with Instrumentation**

     ```js
     class ProductRepository {
       async findAll(category = null, limit = 10) {
         return Sentry.startSpan(
           {
             name: "ProductRepository.findAll",
             attributes: {
               "repository.method": "findAll",
               "repository.entity": "Product",
               "query.category": category,
               "query.limit": limit
             }
           },
           async (span) => {
             let sql = "SELECT * FROM products";
             const params = [];

             if (category) {
               sql += " WHERE category = ?";
               params.push(category);
             }

             sql += " LIMIT ?";
             params.push(limit);

             span.setAttributes({
               "db.prepared_statement": sql,
               "db.params": JSON.stringify(params)
             });

             const result = await db.query(sql, params).all();

             span.setAttributes({
               "repository.result_count": result.length
             });

             // Track repository metrics
             Sentry.metrics.increment('repository.calls', 1, {
               tags: {
                 entity: 'Product',
                 method: 'findAll',
                 has_filter: category ? 'true' : 'false'
               }
             });

             return result;
           }
         );
       }

       async findById(id) {
         return Sentry.startSpan(
           {
             name: "ProductRepository.findById",
             attributes: {
               "repository.method": "findById",
               "repository.entity": "Product",
               "entity.id": id
             }
           },
           async (span) => {
             const sql = "SELECT * FROM products WHERE id = ?";
             const result = await db.query(sql, [id]).get();

             span.setAttributes({
               "repository.found": !!result
             });

             if (!result) {
               Sentry.addBreadcrumb({
                 message: 'Product not found',
                 category: 'repository',
                 level: 'info',
                 data: { productId: id }
               });
             }

             return result;
           }
         );
       }
     }
     ```
</Steps>

### Connection Pool Monitoring

If you're using a connection pool, instrument it as well:

```js
class InstrumentedConnectionPool {
  constructor(poolConfig) {
    this.pool = new ConnectionPool(poolConfig);
    this.setupMonitoring();
  }

  setupMonitoring() {
    // Monitor pool stats
    setInterval(() => {
      const stats = this.pool.getStats();
      
      Sentry.metrics.gauge('db.pool.active_connections', stats.active, {
        tags: { pool: 'main' }
      });
      
      Sentry.metrics.gauge('db.pool.idle_connections', stats.idle, {
        tags: { pool: 'main' }
      });
      
      Sentry.metrics.gauge('db.pool.waiting_requests', stats.waiting, {
        tags: { pool: 'main' }
      });
      
    }, 30000); // Every 30 seconds
  }

  async getConnection() {
    return Sentry.startSpan(
      { name: "db.pool.getConnection" },
      async (span) => {
        const startTime = performance.now();
        
        try {
          const connection = await this.pool.getConnection();
          const waitTime = performance.now() - startTime;
          
          span.setAttributes({
            "db.pool.wait_time": waitTime,
            "operation.success": true
          });

          Sentry.metrics.timing('db.pool.wait_time', waitTime);
          
          return connection;
        } catch (error) {
          span.recordException(error);
          Sentry.metrics.increment('db.pool.errors', 1);
          throw error;
        }
      }
    );
  }
}
```

## Queue and Background Job Instrumentation

:::info[Why Monitor Background Jobs?]
Background jobs often handle critical business logic like:
- Email sending
- Payment processing
- Data synchronization
- Report generation

When these fail silently, it can have serious business impact. Proper monitoring ensures you catch issues quickly.
:::

### Background Job Processing

<Steps>
  1. **Create Instrumented Job Processor**

     ```js
     import * as Sentry from "@sentry/bun";

     class JobProcessor {
       async processJob(job) {
         return Sentry.startSpan(
           {
             name: `job.${job.type}`,
             attributes: {
               "job.id": job.id,
               "job.type": job.type,
               "job.queue": job.queue,
               "job.attempts": job.attempts,
               "job.priority": job.priority
             }
           },
           async (span) => {
             // Set context for this job
             Sentry.getCurrentHub().getScope()?.setTag('job.type', job.type);
             Sentry.getCurrentHub().getScope()?.setContext('job', {
               id: job.id,
               queue: job.queue,
               payload: job.payload
             });

             const startTime = performance.now();
             
             try {
               // Process the job
               const result = await this.executeJob(job);
               const duration = performance.now() - startTime;

               span.setAttributes({
                 "job.duration": duration,
                 "job.status": "completed",
                 "operation.success": true
               });

               // Track job metrics
               Sentry.metrics.timing('job.duration', duration, {
                 tags: {
                   job_type: job.type,
                   queue: job.queue,
                   status: 'completed'
                 }
               });

               Sentry.metrics.increment('job.completed', 1, {
                 tags: {
                   job_type: job.type,
                   queue: job.queue
                 }
               });

               return result;

             } catch (error) {
               const duration = performance.now() - startTime;
               
               span.recordException(error);
               span.setAttributes({
                 "job.duration": duration,
                 "job.status": "failed",
                 "operation.success": false,
                 "error.type": error.name
               });

               // Track job failures
               Sentry.metrics.increment('job.failed', 1, {
                 tags: {
                   job_type: job.type,
                   queue: job.queue,
                   error_type: error.name
                 }
               });

               // Decide whether to retry
               if (job.attempts < job.maxAttempts) {
                 Sentry.addBreadcrumb({
                   message: 'Job failed, will retry',
                   category: 'job',
                   level: 'warning',
                   data: {
                     jobId: job.id,
                     attempt: job.attempts,
                     maxAttempts: job.maxAttempts
                   }
                 });
               }

               throw error;
             }
           }
         );
       }

       async executeJob(job) {
         // Job-specific logic based on job.type
         switch (job.type) {
           case 'send-email':
             return this.sendEmail(job.payload);
           case 'process-payment':
             return this.processPayment(job.payload);
           case 'generate-report':
             return this.generateReport(job.payload);
           default:
             throw new Error(`Unknown job type: ${job.type}`);
         }
       }
     }
     ```

  2. **Queue Monitoring**

     ```js
     class QueueMonitor {
       constructor(queueNames) {
         this.queueNames = queueNames;
         this.startMonitoring();
       }

       startMonitoring() {
         setInterval(async () => {
           for (const queueName of this.queueNames) {
             await this.collectQueueMetrics(queueName);
           }
         }, 60000); // Every minute
       }

       async collectQueueMetrics(queueName) {
         return Sentry.startSpan(
           { name: "queue.metrics.collect" },
           async (span) => {
             try {
               const stats = await this.getQueueStats(queueName);
               
               span.setAttributes({
                 "queue.name": queueName,
                 "queue.pending_jobs": stats.pending,
                 "queue.processing_jobs": stats.processing,
                 "queue.failed_jobs": stats.failed
               });

               // Report queue depth metrics
               Sentry.metrics.gauge('queue.pending_jobs', stats.pending, {
                 tags: { queue: queueName }
               });

               Sentry.metrics.gauge('queue.processing_jobs', stats.processing, {
                 tags: { queue: queueName }
               });

               Sentry.metrics.gauge('queue.failed_jobs', stats.failed, {
                 tags: { queue: queueName }
               });

               // Alert on high queue depth
               if (stats.pending > 1000) {
                 Sentry.captureMessage(`High queue depth detected: ${queueName}`, {
                   level: 'warning',
                   tags: {
                     queue: queueName,
                     pending_jobs: stats.pending
                   }
                 });
               }

             } catch (error) {
               span.recordException(error);
               Sentry.captureException(error);
             }
           }
         );
       }
     }
     ```
</Steps>

## Cache Instrumentation

### Redis/Memory Cache Monitoring

```js
class InstrumentedCache {
  constructor(cacheImplementation) {
    this.cache = cacheImplementation;
  }

  async get(key) {
    return Sentry.startSpan(
      {
        name: "cache.get",
        attributes: {
          "cache.key": key,
          "cache.operation": "get"
        }
      },
      async (span) => {
        const startTime = performance.now();
        
        try {
          const value = await this.cache.get(key);
          const duration = performance.now() - startTime;
          const hit = value !== null && value !== undefined;

          span.setAttributes({
            "cache.hit": hit,
            "cache.duration": duration,
            "operation.success": true
          });

          // Track cache metrics
          Sentry.metrics.timing('cache.operation.duration', duration, {
            tags: {
              operation: 'get',
              result: hit ? 'hit' : 'miss'
            }
          });

          Sentry.metrics.increment('cache.operations', 1, {
            tags: {
              operation: 'get',
              result: hit ? 'hit' : 'miss'
            }
          });

          return value;

        } catch (error) {
          span.recordException(error);
          span.setAttributes({
            "operation.success": false,
            "error.type": error.name
          });

          Sentry.metrics.increment('cache.errors', 1, {
            tags: {
              operation: 'get',
              error_type: error.name
            }
          });

          throw error;
        }
      }
    );
  }

  async set(key, value, ttl = null) {
    return Sentry.startSpan(
      {
        name: "cache.set",
        attributes: {
          "cache.key": key,
          "cache.operation": "set",
          "cache.ttl": ttl
        }
      },
      async (span) => {
        const startTime = performance.now();
        
        try {
          const result = await this.cache.set(key, value, ttl);
          const duration = performance.now() - startTime;

          span.setAttributes({
            "cache.duration": duration,
            "cache.value_size": JSON.stringify(value).length,
            "operation.success": true
          });

          Sentry.metrics.timing('cache.operation.duration', duration, {
            tags: { operation: 'set' }
          });

          return result;

        } catch (error) {
          span.recordException(error);
          Sentry.metrics.increment('cache.errors', 1, {
            tags: { operation: 'set' }
          });
          throw error;
        }
      }
    );
  }

  // Monitor cache statistics
  async reportCacheStats() {
    try {
      const stats = await this.cache.getStats();
      
      Sentry.metrics.gauge('cache.memory_usage', stats.memoryUsage);
      Sentry.metrics.gauge('cache.key_count', stats.keyCount);
      Sentry.metrics.gauge('cache.hit_rate', stats.hitRate);
      
    } catch (error) {
      Sentry.captureException(error);
    }
  }
}

// Usage with automatic stats reporting
const cache = new InstrumentedCache(redisClient);
setInterval(() => cache.reportCacheStats(), 60000);
```

## Performance Analysis and Alerting

### Set Up Performance Alerts

1. **Slow Database Queries**
   - Alert when `db.query.duration` > 500ms
   - Threshold: 5+ occurrences in 10 minutes

2. **High Database Error Rate**  
   - Alert when `db.errors` rate > 1%
   - Time window: 5 minutes

3. **Queue Depth Alerts**
   - Alert when `queue.pending_jobs` > 1000
   - Check every minute

4. **Cache Hit Rate Alerts**
   - Alert when `cache.hit_rate` < 80%
   - Time window: 15 minutes

### Create Custom Queries

Use Sentry's Discover to analyze your data:

```sql
-- Find slowest database operations
SELECT 
  db.operation,
  db.table,
  avg(db.duration) as avg_duration,
  count() as query_count
FROM spans
WHERE span.name LIKE 'db.%'
  AND timestamp >= '2024-01-01'
GROUP BY db.operation, db.table
ORDER BY avg_duration DESC;

-- Analyze job failure patterns
SELECT 
  job.type,
  job.queue,
  count() as failures,
  count_if(job.attempts >= job.max_attempts) as permanent_failures
FROM spans
WHERE span.name LIKE 'job.%'
  AND operation.success = false
GROUP BY job.type, job.queue;
```

## Testing Your Data Layer Instrumentation

<Steps>
  1. **Generate Test Scenarios**

     ```js
     // test-data-layer.js
     const testDatabase = async () => {
       // Test normal queries
       await productRepo.findAll('electronics', 10);
       
       // Test slow queries (large result sets)
       await productRepo.findAll(null, 10000);
       
       // Test error scenarios
       try {
         await productRepo.findById('invalid-id');
       } catch (error) {
         // Expected error
       }
     };

     const testJobs = async () => {
       // Process various job types
       await jobProcessor.processJob({ type: 'send-email', payload: {...} });
       await jobProcessor.processJob({ type: 'process-payment', payload: {...} });
       
       // Test job failures
       await jobProcessor.processJob({ type: 'invalid-job', payload: {...} });
     };

     const testCache = async () => {
       // Test cache hits and misses
       await cache.get('existing-key');
       await cache.get('non-existing-key');
       await cache.set('new-key', { data: 'value' }, 3600);
     };
     ```

  2. **Verify Instrumentation**

     Check in Sentry that you can see:
     - Database query spans with performance metrics
     - Job processing traces with success/failure status
     - Cache operation metrics and hit rates
     - Proper error handling and context
</Steps>

## Next Steps

With your data layer fully instrumented, move on to [Visualizing Traces in Sentry](/visualizing-traces/) to learn how to effectively analyze and debug your application using Sentry's visualization tools.